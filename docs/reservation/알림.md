# 알림 시스템 아키텍처 및 구현

## 1. 핵심 설계 원칙 (Synchronous Save + Asynchronous Delivery)
본 프로젝트의 알림 시스템은 **데이터 정합성(Consistency)**과 **응답 속도(Performance)**를 모두 만족시키기 위해 **"동기 저장 후 비동기 전송"** 방식을 채택했습니다.

### 1.1 저장 (Persistence): 동기 처리 (Synchronous)
- **방식**: `ProjectApplicationService` 등 메인 비즈니스 로직을 수행하는 트랜잭션 내부에서 `NotificationRepository.save()`를 직접 호출합니다.
- **이유**: 알림은 사용자에게 중요한 히스토리 데이터입니다. 메인 로직(지원, 승인 등)이 성공했다면, 알림 내역 또한 **반드시 DB에 저장됨을 보장(Atomicity)**해야 합니다.

### 1.2 전송 (Delivery): 비동기 처리 (Asynchronous)
- **방식**: 트랜잭션이 커밋된 후(`AFTER_COMMIT`), 이벤트를 발행하여 `SSENotificationService`에서 별도의 스레드로 SSE(Server-Sent Events)를 전송합니다.
- **이유**: 외부 네트워크 통신(SSE 연결)이나 전송 지연이 사용자 경험(API 응답 속도)에 영향을 주지 않도록 하기 위함입니다. 전송이 실패하더라도 이미 저장된 DB 데이터는 안전합니다.

---

## 2. 상세 프로세스

### 2.1 일반 알림 (지원, 승인, 거절 등)
대부분의 1:1 알림(`PROJECT_APPLY`, `PROJECT_MY_APPLY`, `PROJECT_APPROVE`, `PROJECT_REJECT`)은 아래 흐름을 따릅니다.

1.  **Service (Main Transaction)**
    *   비즈니스 로직 수행 (예: 지원서 저장)
    *   **`Notification` 엔티티 생성 및 저장 (INSERT)**
    *   `NotificationEvent` 발행
2.  **NotificationListener**
    *   트랜잭션 커밋 후 이벤트 수신
    *   `SSENotificationService.notify()` 호출 (비동기)
3.  **SSENotificationService**
    *   전달받은 정보로 `Payload` 생성
    *   **SSE 전송 (`try-catch`로 안전하게 처리)**
    *   *저장 로직 없음 (이미 1단계에서 저장됨)*

### 2.2 배치성 알림 (프로젝트 종료)
다수에게 발송되는 `PROJECT_END` 알림은 예외적으로 **전체 비동기**로 처리합니다.
- **이유**: 팀원이 많을 경우 반복적인 저장 작업이 메인 로직(프로젝트 삭제)의 응답 속도를 저하시킬 수 있기 때문입니다.
- **흐름**: 프로젝트 삭제 -> 이벤트 발행 -> **(비동기) 멤버 조회 및 알림 저장** -> (비동기) SSE 전송

---

## 3. 리팩토링 히스토리 & 변경 사항

### 3.1 주요 변경 사항
- **구조 변경**: `SSENotificationService`에서 수행하던 알림 저장을 `ProjectApplicationService` 등 호출부로 이동하여 데이터 유실 가능성을 차단했습니다.
- **NotificationType 이름 변경**: API 명세 일치 (`PROJECT_SELF_APPLY` -> `PROJECT_MY_APPLY` 등).
- **이중 저장 방지**: 서비스 계층에서 저장하고, SSE 서비스에서는 전송만 담당하도록 역할을 엄격히 분리했습니다.

## 4. 알림 응답 구조 (JSON)
상세한 응답 포맷은 `docs/알림_응답.md`를 참고하십시오.